<!DOCTYPE html>


<html theme="dark" showBanner="true" hasBanner="true" > 
<link href="https://cdn.staticfile.org/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet">
<link href="https://cdn.staticfile.org/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet">
<link href="https://cdn.staticfile.org/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet">
<script src="/js/color.global.min.js" ></script>
<script src="/js/load-settings.js" ></script>
<head>
  <meta charset="utf-8">
  
  
  
<!-- Gaug.es Analytics -->
<script>
  var _gauges = _gauges || [];
  (function() {
    var t   = document.createElement('script');
    t.async = true;
    t.id    = 'gauges-tracker';
    t.setAttribute('data-site-id', 'true');
    t.setAttribute('data-track-path', 'https://track.gaug.es/track.gif');
    t.src = 'https://d36ee2fcip1434.cloudfront.net/track.js';
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(t, s);
  })();
</script>
<!-- End Gaug.es Analytics -->


  
  <title>Go 1.22 中 for 循环语义的变化(转载翻译) | Code</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="preload" href="/css/fonts/Roboto-Regular.ttf" as="font" type="font/ttf" crossorigin="anonymous">
  <link rel="preload" href="/css/fonts/Roboto-Bold.ttf" as="font" type="font/ttf" crossorigin="anonymous">

  <meta name="description" content="改变了什么？ 变更的影响 延迟调用捕获循环变量的行为可能会发生变化 在闭包中捕获循环变量时要小心 在获取循环变量的地址时要小心 将第三个子句语句移到循环体内时要小心 在声明不可复制的值作为循环变量时要小心 警告：你的 Go 程序的性能可能会默默地降低 警告：当循环变量被并发使用时，情况可能会变得比以前更加微妙 一些建议 为 Go 源文件指定 Go 语言版本 升级模块版本 如果你担心会受到新语">
<meta property="og:type" content="article">
<meta property="og:title" content="Go 1.22 中 for 循环语义的变化(转载翻译)">
<meta property="og:url" content="http://example.com/2024/03/14/go-for/index.html">
<meta property="og:site_name" content="Code">
<meta property="og:description" content="改变了什么？ 变更的影响 延迟调用捕获循环变量的行为可能会发生变化 在闭包中捕获循环变量时要小心 在获取循环变量的地址时要小心 将第三个子句语句移到循环体内时要小心 在声明不可复制的值作为循环变量时要小心 警告：你的 Go 程序的性能可能会默默地降低 警告：当循环变量被并发使用时，情况可能会变得比以前更加微妙 一些建议 为 Go 源文件指定 Go 语言版本 升级模块版本 如果你担心会受到新语">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2024-03-14T13:59:53.000Z">
<meta property="article:modified_time" content="2024-03-14T15:35:20.949Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="for循环">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Code" type="application/atom+xml">
  
  
    <link rel="icon" media="(prefers-color-scheme: light)" href="/images/favicon-light-32.png" sizes="32x32">
    <link rel="icon" media="(prefers-color-scheme: light)" href="/images/favicon-light-128.png" sizes="128x128">
    <link rel="icon" media="(prefers-color-scheme: light)" href="/images/favicon-light-180.png" sizes="180x180">
    <link rel="icon" media="(prefers-color-scheme: light)" href="/images/favicon-light-192.png" sizes="192x192">
    <link rel="icon" media="(prefers-color-scheme: dark)" href="/images/favicon-dark-32.png" sizes="32x32">
    <link rel="icon" media="(prefers-color-scheme: dark)" href="/images/favicon-dark-128.png" sizes="128x128">
    <link rel="icon" media="(prefers-color-scheme: dark)" href="/images/favicon-dark-180.png" sizes="180x180">
    <link rel="icon" media="(prefers-color-scheme: dark)" href="/images/favicon-dark-192.png" sizes="192x192">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  
  
    
<div id="banner" class="">
  <img src="https://c-ssl.duitang.com/uploads/blog/202103/16/20210316041943_4bea4.png" itemprop="image">
  <div id="banner-dim"></div>
</div>
 
   
  <div id="main-grid" class="shadow   ">
    <div id="nav" class=""  >
      <navbar id="navbar">
  <nav id="title-nav">
    <a href="/">
      <div id="vivia-logo">
        <div class="dot"></div>
        <div class="dot"></div>
        <div class="dot"></div>
        <div class="dot"></div>
      </div>
      <div>Code </div>
    </a>
  </nav>
  <nav id="main-nav">
    
      <a class="main-nav-link" href="/">主页</a>
    
      <a class="main-nav-link" href="/archives">归档</a>
    
      <a class="main-nav-link" href="/about">关于</a>
    
  </nav>
  <nav id="sub-nav">
    <a id="theme-btn" class="nav-icon">
      <span class="light-mode-icon"><svg xmlns="http://www.w3.org/2000/svg" height="20" viewBox="0 -960 960 960" width="20"><path d="M438.5-829.913v-48q0-17.452 11.963-29.476 11.964-12.024 29.326-12.024 17.363 0 29.537 12.024t12.174 29.476v48q0 17.452-11.963 29.476-11.964 12.024-29.326 12.024-17.363 0-29.537-12.024T438.5-829.913Zm0 747.826v-48q0-17.452 11.963-29.476 11.964-12.024 29.326-12.024 17.363 0 29.537 12.024t12.174 29.476v48q0 17.452-11.963 29.476-11.964 12.024-29.326 12.024-17.363 0-29.537-12.024T438.5-82.087ZM877.913-438.5h-48q-17.452 0-29.476-11.963-12.024-11.964-12.024-29.326 0-17.363 12.024-29.537t29.476-12.174h48q17.452 0 29.476 11.963 12.024 11.964 12.024 29.326 0 17.363-12.024 29.537T877.913-438.5Zm-747.826 0h-48q-17.452 0-29.476-11.963-12.024-11.964-12.024-29.326 0-17.363 12.024-29.537T82.087-521.5h48q17.452 0 29.476 11.963 12.024 11.964 12.024 29.326 0 17.363-12.024 29.537T130.087-438.5Zm660.174-290.87-34.239 32q-12.913 12.674-29.565 12.174-16.653-.5-29.327-13.174-12.674-12.673-12.554-28.826.12-16.152 12.794-28.826l33-35q12.913-12.674 30.454-12.674t30.163 12.847q12.709 12.846 12.328 30.826-.38 17.98-13.054 30.653ZM262.63-203.978l-32 34q-12.913 12.674-30.454 12.674t-30.163-12.847q-12.709-12.846-12.328-30.826.38-17.98 13.054-30.653l33.239-31q12.913-12.674 29.565-12.174 16.653.5 29.327 13.174 12.674 12.673 12.554 28.826-.12 16.152-12.794 28.826Zm466.74 33.239-32-33.239q-12.674-12.913-12.174-29.565.5-16.653 13.174-29.327 12.673-12.674 28.826-13.054 16.152-.38 28.826 12.294l35 33q12.674 12.913 12.674 30.454t-12.847 30.163q-12.846 12.709-30.826 12.328-17.98-.38-30.653-13.054ZM203.978-697.37l-34-33q-12.674-12.913-13.174-29.945-.5-17.033 12.174-29.707t31.326-13.293q18.653-.62 31.326 13.054l32 34.239q11.674 12.913 11.174 29.565-.5 16.653-13.174 29.327-12.673 12.674-28.826 12.554-16.152-.12-28.826-12.794ZM480-240q-100 0-170-70t-70-170q0-100 70-170t170-70q100 0 170 70t70 170q0 100-70 170t-170 70Zm-.247-82q65.703 0 111.475-46.272Q637-414.544 637-480.247t-45.525-111.228Q545.95-637 480.247-637t-111.475 45.525Q323-545.95 323-480.247t45.525 111.975Q414.05-322 479.753-322ZM481-481Z"/></svg></span>
      <span class="dark-mode-icon"><svg xmlns="http://www.w3.org/2000/svg" height="20" viewBox="0 -960 960 960" width="20"><path d="M480.239-116.413q-152.63 0-258.228-105.478Q116.413-327.37 116.413-480q0-130.935 77.739-227.435t206.304-125.043q43.022-9.631 63.87 10.869t3.478 62.805q-8.891 22.043-14.315 44.463-5.424 22.42-5.424 46.689 0 91.694 64.326 155.879 64.325 64.186 156.218 64.186 24.369 0 46.978-4.946 22.609-4.945 44.413-14.076 42.826-17.369 62.967 1.142 20.142 18.511 10.511 61.054Q807.174-280 712.63-198.206q-94.543 81.793-232.391 81.793Zm0-95q79.783 0 143.337-40.217 63.554-40.218 95.793-108.283-15.608 4.044-31.097 5.326-15.49 1.283-31.859.805-123.706-4.066-210.777-90.539-87.071-86.473-91.614-212.092-.24-16.369.923-31.978 1.164-15.609 5.446-30.978-67.826 32.478-108.282 96.152Q211.652-559.543 211.652-480q0 111.929 78.329 190.258 78.329 78.329 190.258 78.329ZM466.13-465.891Z"/></svg></span>
    </a>
    
      <a id="nav-rss-link" class="nav-icon mobile-hide" href="/atom.xml" title="RSS 订阅">
        <svg xmlns="http://www.w3.org/2000/svg" height="20" viewBox="0 -960 960 960" width="20"><path d="M198-120q-25.846 0-44.23-18.384-18.384-18.385-18.384-44.23 0-25.846 18.384-44.23 18.384-18.385 44.23-18.385 25.846 0 44.23 18.385 18.384 18.384 18.384 44.23 0 25.845-18.384 44.23Q223.846-120 198-120Zm538.385 0q-18.846 0-32.923-13.769-14.076-13.769-15.922-33.23-8.692-100.616-51.077-188.654-42.385-88.039-109.885-155.539-67.5-67.501-155.539-109.885Q283-663.462 182.385-672.154q-19.461-1.846-33.23-16.23-13.769-14.385-13.769-33.846t14.076-32.922q14.077-13.461 32.923-12.23 120.076 8.692 226.038 58.768 105.961 50.077 185.73 129.846 79.769 79.769 129.846 185.731 50.077 105.961 58.769 226.038 1.231 18.846-12.538 32.922Q756.461-120 736.385-120Zm-252 0q-18.231 0-32.423-13.461t-18.653-33.538Q418.155-264.23 348.886-333.5q-69.27-69.27-166.501-84.423-20.077-4.462-33.538-18.961-13.461-14.5-13.461-33.346 0-19.076 13.884-33.23 13.884-14.153 33.115-10.922 136.769 15.384 234.384 112.999 97.615 97.615 112.999 234.384 3.231 19.23-10.538 33.115Q505.461-120 484.385-120Z"/></svg>
      </a>
    
    <div id="nav-menu-btn" class="nav-icon">
      <svg xmlns="http://www.w3.org/2000/svg" height="20" viewBox="0 -960 960 960" width="20"><path d="M177.37-252.282q-17.453 0-29.477-11.964-12.024-11.963-12.024-29.326t12.024-29.537q12.024-12.174 29.477-12.174h605.26q17.453 0 29.477 11.964 12.024 11.963 12.024 29.326t-12.024 29.537q-12.024 12.174-29.477 12.174H177.37Zm0-186.218q-17.453 0-29.477-11.963-12.024-11.964-12.024-29.326 0-17.363 12.024-29.537T177.37-521.5h605.26q17.453 0 29.477 11.963 12.024 11.964 12.024 29.326 0 17.363-12.024 29.537T782.63-438.5H177.37Zm0-186.217q-17.453 0-29.477-11.964-12.024-11.963-12.024-29.326t12.024-29.537q12.024-12.174 29.477-12.174h605.26q17.453 0 29.477 11.964 12.024 11.963 12.024 29.326t-12.024 29.537q-12.024 12.174-29.477 12.174H177.37Z"/></svg>
    </div>
  </nav>
</navbar>
<div id="nav-dropdown" class="hidden">
  <div id="dropdown-link-list">
    
      <a class="nav-dropdown-link" href="/">主页</a>
    
      <a class="nav-dropdown-link" href="/archives">归档</a>
    
      <a class="nav-dropdown-link" href="/about">关于</a>
    
    
      <a class="nav-dropdown-link" href="/atom.xml" title="RSS 订阅">RSS</a>
     
    </div>
</div>
<script>
  let dropdownBtn = document.getElementById("nav-menu-btn");
  let dropdownEle = document.getElementById("nav-dropdown");
  dropdownBtn.onclick = function() {
    dropdownEle.classList.toggle("hidden");
  }
</script>
    </div>
    <div id="sidebar-wrapper">
      <sidebar id="sidebar">
  
    <div class="widget-wrap">
  <div class="info-card">
    <div class="avatar">
      
        <image src=/avatar/%E7%8C%AB%E7%BE%BD%E9%9B%AB.jpg></image>
      
      <div class="img-dim"></div>
    </div>
    <div class="info">
      <div class="username">threeWater </div>
      <div class="dot"></div>
      <div class="subtitle">This is the subtitle </div>
      <div class="link-list">
        
          <a class="link-btn" target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp" title="C++ reference"><i class="fa-solid fa-link"></i></a>
        
          <a class="link-btn" target="_blank" rel="noopener" href="https://godbolt.org/" title="Compiler Explorer"><i class="fa-solid fa-code"></i></a>
        
          <a class="link-btn" target="_blank" rel="noopener" href="https://github.com" title="GitHub"><i class="fa-brands fa-github"></i></a>
         
      </div>  
    </div>
  </div>
</div>

  
  <div class="sticky">
    
      


  <div class="widget-wrap">
    <div class="widget">
      <h3 class="widget-title">分类</h3>
      <div class="category-box">
            <a class="category-link" href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">
                设计模式
                <div class="category-count">1</div>
            </a>
        
            <a class="category-link" href="/categories/Rust/">
                Rust
                <div class="category-count">1</div>
            </a>
        
            <a class="category-link" href="/categories/C/">
                C++
                <div class="category-count">2</div>
            </a>
        
            <a class="category-link" href="/categories/VSCode/">
                VSCode
                <div class="category-count">1</div>
            </a>
        <div class="children"><div class="category-box">
            <a class="category-link" href="/categories/VSCode/C-C/">
                C/C++
                <div class="category-count">1</div>
            </a>
        </div></div>
            <a class="category-link" href="/categories/Go/">
                Go
                <div class="category-count">1</div>
            </a>
        </div>
    </div>
  </div>


    
      
  <div class="widget-wrap">
    <div class="widget">
      <h3 class="widget-title">标签</h3>
      <ul class="widget-tag-list" itemprop="keywords"><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/tags/for%E5%BE%AA%E7%8E%AF/" rel="tag">for循环</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/tags/%E5%85%A5%E9%97%A8/" rel="tag">入门</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/tags/%E5%BC%95%E7%94%A8/" rel="tag">引用</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/tags/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/" rel="tag">环境配置</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/tags/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/" rel="tag">生命周期</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/tags/%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/" rel="tag">运算符重载</a></li></ul>
    </div>
  </div>


    
      
  <div class="widget-wrap">
    <div class="widget">
      <h3 class="widget-title">归档</h3>
      
      
        <a class="archive-link" href="/archives/2024/03 ">
          三月 2024 
          <div class="archive-count">1 </div>
        </a>
      
        <a class="archive-link" href="/archives/2024/02 ">
          二月 2024 
          <div class="archive-count">1 </div>
        </a>
      
        <a class="archive-link" href="/archives/2023/12 ">
          十二月 2023 
          <div class="archive-count">1 </div>
        </a>
      
        <a class="archive-link" href="/archives/2023/11 ">
          十一月 2023 
          <div class="archive-count">4 </div>
        </a>
      
    </div>
  </div>


    
      
  <div class="widget-wrap">
    <div class="widget">
      <h3 class="widget-title">最新文章</h3>
      <ul>
        
          <a class="recent-link" href="/2024/03/14/go-for/" title="Go 1.22 中 for 循环语义的变化(转载翻译)" >
            <div class="recent-link-text">
              Go 1.22 中 for 循环语义的变化(转载翻译)
            </div>
          </a>
        
          <a class="recent-link" href="/2024/02/15/Rust%E5%BC%95%E7%94%A8%E5%AE%89%E5%85%A8/" title="Rust引用安全" >
            <div class="recent-link-text">
              Rust引用安全
            </div>
          </a>
        
          <a class="recent-link" href="/2023/12/11/vscode%E9%85%8D%E7%BD%AEC++%E7%8E%AF%E5%A2%83/" title="VSCode配置C++环境(小白)" >
            <div class="recent-link-text">
              VSCode配置C++环境(小白)
            </div>
          </a>
        
          <a class="recent-link" href="/2023/11/20/23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" title="23种设计模式" >
            <div class="recent-link-text">
              23种设计模式
            </div>
          </a>
        
          <a class="recent-link" href="/2023/11/19/%E7%BD%95%E6%9C%89%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/" title="为智能指针实现operator->*的方式 ——Scott Meyers" >
            <div class="recent-link-text">
              为智能指针实现operator-&gt;*的方式 ——Scott Meyers
            </div>
          </a>
        
      </ul>
    </div>
  </div>

    
  </div>
</sidebar>
    </div>
    <div id="content-body">
       


<article id="post-go-for" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  
    
   
  <div class="article-inner">
    <div class="article-main">
      <header class="article-header">
        
<div class="main-title-bar">
  <div class="main-title-dot"></div>
  
    
      <h1 class="p-name article-title" itemprop="headline name">
        Go 1.22 中 for 循环语义的变化(转载翻译)
      </h1>
    
  
</div>

        <div class='meta-info-bar'>
          <div class="meta-info">
  <time class="dt-published" datetime="2024-03-14T13:59:53.000Z" itemprop="datePublished">2024-03-14</time>
</div>
          <div class="need-seperator meta-info">
            <div class="meta-cate-flex">
  
  <a class="meta-cate-link" href="/categories/Go/">Go</a>
   
</div>
  
          </div>
          <div class="wordcount need-seperator meta-info">
            18k 词 
          </div>
        </div>
        
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/for%E5%BE%AA%E7%8E%AF/" rel="tag">for循环</a></li></ul>

      </header>
      <div class="e-content article-entry" itemprop="articleBody">
        
          <!-- toc -->

<ul>
<li><a href="#%E6%94%B9%E5%8F%98%E4%BA%86%E4%BB%80%E4%B9%88">改变了什么？</a></li>
<li><a href="#%E5%8F%98%E6%9B%B4%E7%9A%84%E5%BD%B1%E5%93%8D">变更的影响</a></li>
<li><a href="#%E5%BB%B6%E8%BF%9F%E8%B0%83%E7%94%A8%E6%8D%95%E8%8E%B7%E5%BE%AA%E7%8E%AF%E5%8F%98%E9%87%8F%E7%9A%84%E8%A1%8C%E4%B8%BA%E5%8F%AF%E8%83%BD%E4%BC%9A%E5%8F%91%E7%94%9F%E5%8F%98%E5%8C%96">延迟调用捕获循环变量的行为可能会发生变化</a></li>
<li><a href="#%E5%9C%A8%E9%97%AD%E5%8C%85%E4%B8%AD%E6%8D%95%E8%8E%B7%E5%BE%AA%E7%8E%AF%E5%8F%98%E9%87%8F%E6%97%B6%E8%A6%81%E5%B0%8F%E5%BF%83">在闭包中捕获循环变量时要小心</a></li>
<li><a href="#%E5%9C%A8%E8%8E%B7%E5%8F%96%E5%BE%AA%E7%8E%AF%E5%8F%98%E9%87%8F%E7%9A%84%E5%9C%B0%E5%9D%80%E6%97%B6%E8%A6%81%E5%B0%8F%E5%BF%83">在获取循环变量的地址时要小心</a></li>
<li><a href="#%E5%B0%86%E7%AC%AC%E4%B8%89%E4%B8%AA%E5%AD%90%E5%8F%A5%E8%AF%AD%E5%8F%A5%E7%A7%BB%E5%88%B0%E5%BE%AA%E7%8E%AF%E4%BD%93%E5%86%85%E6%97%B6%E8%A6%81%E5%B0%8F%E5%BF%83">将第三个子句语句移到循环体内时要小心</a></li>
<li><a href="#%E5%9C%A8%E5%A3%B0%E6%98%8E%E4%B8%8D%E5%8F%AF%E5%A4%8D%E5%88%B6%E7%9A%84%E5%80%BC%E4%BD%9C%E4%B8%BA%E5%BE%AA%E7%8E%AF%E5%8F%98%E9%87%8F%E6%97%B6%E8%A6%81%E5%B0%8F%E5%BF%83">在声明不可复制的值作为循环变量时要小心</a></li>
<li><a href="#%E8%AD%A6%E5%91%8A%E4%BD%A0%E7%9A%84-go-%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%80%A7%E8%83%BD%E5%8F%AF%E8%83%BD%E4%BC%9A%E9%BB%98%E9%BB%98%E5%9C%B0%E9%99%8D%E4%BD%8E">警告：你的 Go 程序的性能可能会默默地降低</a></li>
<li><a href="#%E8%AD%A6%E5%91%8A%E5%BD%93%E5%BE%AA%E7%8E%AF%E5%8F%98%E9%87%8F%E8%A2%AB%E5%B9%B6%E5%8F%91%E4%BD%BF%E7%94%A8%E6%97%B6%E6%83%85%E5%86%B5%E5%8F%AF%E8%83%BD%E4%BC%9A%E5%8F%98%E5%BE%97%E6%AF%94%E4%BB%A5%E5%89%8D%E6%9B%B4%E5%8A%A0%E5%BE%AE%E5%A6%99">警告：当循环变量被并发使用时，情况可能会变得比以前更加微妙</a></li>
<li><a href="#%E4%B8%80%E4%BA%9B%E5%BB%BA%E8%AE%AE">一些建议</a><ul>
<li><a href="#%E4%B8%BA-go-%E6%BA%90%E6%96%87%E4%BB%B6%E6%8C%87%E5%AE%9A-go-%E8%AF%AD%E8%A8%80%E7%89%88%E6%9C%AC">为 Go 源文件指定 Go 语言版本</a></li>
<li><a href="#%E5%8D%87%E7%BA%A7%E6%A8%A1%E5%9D%97%E7%89%88%E6%9C%AC">升级模块版本</a></li>
<li><a href="#%E5%A6%82%E6%9E%9C%E4%BD%A0%E6%8B%85%E5%BF%83%E4%BC%9A%E5%8F%97%E5%88%B0%E6%96%B0%E8%AF%AD%E4%B9%89%E7%9A%84%E5%BD%B1%E5%93%8D%E5%BB%BA%E8%AE%AE%E9%81%BF%E5%85%8D%E5%9C%A8-for-%E5%BE%AA%E7%8E%AF%E4%B8%AD%E4%BD%BF%E7%94%A8%E6%96%B0%E5%A3%B0%E6%98%8E%E7%9A%84%E5%BE%AA%E7%8E%AF%E5%8F%98%E9%87%8F">如果你担心会受到新语义的影响，建议避免在 <code>for;;</code> 循环中使用新声明的循环变量</a></li>
</ul>
</li>
<li><a href="#%E7%BB%93%E8%AF%AD">结语</a></li>
</ul>
<!-- tocstop -->

<p>Go 1.22 改变了 <code>for</code> 循环的语义，包括 <code>for-range</code> 循环和传统的 3-子句 <code>for ..; ..; .. &#123;...&#125;</code> 循环（本文剩余部分将简称为 <code>for;;</code>）</p>
<p>您应该理解这些语义变化，并了解这些变化的影响，以便编写预期行为的 Go 代码。否则，您的代码可能会出现意外行为</p>
<h2><span id="改变了什么">改变了什么？</span></h2><p>具体来说，只有在循环中声明循环变量的 <code>for</code> 循环的语义发生了变化（我们将这样的循环变量称为在本文剩余部分中称为新声明的循环变量）。例如，在以下代码片段中，前两个循环的语义未更改，但后两个循环的语义已更改（从 Go 1.21 到 1.22）</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> k, v = <span class="keyword">range</span> aContainer &#123;...&#125;</span><br><span class="line"><span class="keyword">for</span> a, b, c = f(); condition; statement &#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> k, v := <span class="keyword">range</span> aContainer &#123;...&#125;</span><br><span class="line"><span class="keyword">for</span> a, b, c := f(); condition; statement &#123;...&#125;</span><br></pre></td></tr></table></figure>
<p>前两个循环没有声明它们各自的循环变量，但后两个循环声明了。这就是其中的区别。前两个循环的语义没有改变。</p>
<p>让我们查看一个简单的 Go 程序，它从 Go 1.21 变到 Go 1.22 发生了语义变化（以及行为变化）:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//demo1.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	c, out := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>), <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line"></span><br><span class="line">	m := <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>&#123;<span class="number">1</span>: <span class="number">2</span>, <span class="number">3</span>: <span class="number">4</span>&#125;</span><br><span class="line">	<span class="keyword">for</span> i, v := <span class="keyword">range</span> m &#123;</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			&lt;-c</span><br><span class="line">			out &lt;- i+v</span><br><span class="line">		&#125;()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">close</span>(c)</span><br><span class="line"></span><br><span class="line">	<span class="built_in">println</span>(&lt;-out + &lt;-out)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以安装多个 Go 工具链版本来检查输出。在这里，我使用 <code>GoTV</code> 工具( <a target="_blank" rel="noopener" href="https://go101.org/apps-and-libs/gotv.html">https://go101.org/apps-and-libs/gotv.html</a> )来（方便地）选择 Go 工具链版本</p>
<p>输出：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ gotv <span class="number">1.21</span>. run demo1.<span class="keyword">go</span></span><br><span class="line">[Run]: $HOME/.cache/gotv/tag_go1<span class="number">.21</span><span class="number">.7</span>/bin/<span class="keyword">go</span> run demo1.<span class="keyword">go</span></span><br><span class="line"><span class="number">14</span></span><br><span class="line">$ gotv <span class="number">1.22</span>. run demo1.<span class="keyword">go</span></span><br><span class="line">[Run]: $HOME/.cache/gotv/tag_go1<span class="number">.22</span><span class="number">.0</span>/bin/<span class="keyword">go</span> run demo1.<span class="keyword">go</span></span><br><span class="line"><span class="number">10</span></span><br></pre></td></tr></table></figure>
<p>行为差异是明显的：</p>
<ul>
<li>在 Go 1.22 之前，它（更可能）打印 <code>14</code>；</li>
<li>自 Go 1.22 起，它（始终）打印 <code>10</code></li>
</ul>
<p>造成差异的原因：</p>
<ul>
<li>在 Go 1.22 之前，在 <code>for</code> 循环中使用的每个新声明的循环变量被所有迭代共享。两个新创建的 goroutine 更可能在执行 <code>for</code> 循环之后执行，此时 <code>i</code> 和 <code>v</code> 循环变量的最终值分别为 <code>3</code> 和 <code>4</code>。<code>（3+4）+（3+4）</code>得到 <code>14</code></li>
<li>自 Go 1.22 起，在 <code>for</code> 循环中使用的每个新声明的循环变量将在每次迭代开始时实例化为一个独立的实例。换句话说，现在是按迭代范围进行作用域管理。因此，在两个新创建的 goroutine 中使用的 <code>i</code> 和 <code>v</code> 循环变量的值分别为 <code>1 2</code> 和 <code>3 4</code>。<code>（1+2）+（3+4）</code>得到 <code>10</code></li>
</ul>
<p>在 Go 1.22 之前，上述程序代码存在数据竞争条件，这对于一个有能力的 Go<br>程序员来说应该是一个明显的事实。为了避免数据竞争并获得与新语义相同的结果，程序中的循环应该重写为：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i, v := <span class="keyword">range</span> m &#123;</span><br><span class="line">	i, v := i, v <span class="comment">// this line is added</span></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		&lt;-c</span><br><span class="line">		out &lt;- i+v</span><br><span class="line">	&#125;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在新语义下，添加的那一行变得不必要了。实际上，这是为什么在 Go 1.22 中进行语义更改的主要原因</p>
<p>同样，下面的程序在从 Go 1.21 到 Go 1.22 期间也会经历语义&#x2F;行为变化：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// demo2.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	c, out := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>), <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="number">3</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			&lt;-c</span><br><span class="line">			out &lt;- i</span><br><span class="line">		&#125;()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">close</span>(c)</span><br><span class="line"></span><br><span class="line">	<span class="built_in">println</span>(&lt;-out + &lt;-out + &lt;-out)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面程序的输出（类似地，对于 1.21 版本，更可能是这样，对于 1.22 版本，总是这样）：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ gotv <span class="number">1.21</span>. run demo2.<span class="keyword">go</span></span><br><span class="line">[Run]: $HOME/.cache/gotv/tag_go1<span class="number">.21</span><span class="number">.7</span>/bin/<span class="keyword">go</span> run demo2.<span class="keyword">go</span></span><br><span class="line"><span class="number">12</span></span><br><span class="line">$ gotv <span class="number">1.22</span>. run demo2.<span class="keyword">go</span></span><br><span class="line">[Run]: $HOME/.cache/gotv/tag_go1<span class="number">.22</span><span class="number">.0</span>/bin/<span class="keyword">go</span> run demo2.<span class="keyword">go</span> </span><br><span class="line"><span class="number">6</span></span><br></pre></td></tr></table></figure>
<p>本文侧重于变化的细节和影响，而不是背后的原因。有关批准过程和变更背后的原因的详细信息，请参阅：</p>
<ol>
<li>第一次讨论：重新定义 for 循环变量语义：<a target="_blank" rel="noopener" href="https://github.com/golang/go/discussions/56010">https://github.com/golang/go/discussions/56010</a></li>
<li>正式提案问题线程：<a target="_blank" rel="noopener" href="https://github.com/golang/go/issues/60078">https://github.com/golang/go/issues/60078</a></li>
<li>提案文件本身：<a target="_blank" rel="noopener" href="https://go.googlesource.com/proposal/+/master/design/60078-loopvar.md">https://go.googlesource.com/proposal/+/master/design/60078-loopvar.md</a> （如果你只关心原因，可以只阅读这个）</li>
<li>维基页面：<a target="_blank" rel="noopener" href="https://go.dev/wiki/LoopvarExperiment">https://go.dev/wiki/LoopvarExperiment</a> 以及博客文章： <a target="_blank" rel="noopener" href="https://go.dev/blog/loopvar-preview">https://go.dev/blog/loopvar-preview</a> 这两个都是在提案被接受后创建的，这意味着实验阶段是在提案被接受后开始的</li>
<li>Go 1.22 发布说明：<a target="_blank" rel="noopener" href="https://go.dev/doc/go1.22">https://go.dev/doc/go1.22</a> 其中声明该发布版本保持了 Go 1 的兼容性承诺( <a target="_blank" rel="noopener" href="https://go.dev/doc/go1compat">https://go.dev/doc/go1compat</a> )。然而，事实并非如此（请阅读下面的原因）</li>
</ol>
<h2><span id="变更的影响">变更的影响</span></h2><p>就个人而言，我认为对于 <code>for-range</code> 循环的更改是合理的。新的 <code>for-range</code> 循环语义更加直观。这种变化只影响了 <code>for k, v := range .. &#123;...&#125;</code> 循环，其中 <code>:=</code> 符号强烈暗示循环变量是按迭代范围作用域的。没有引入任何含义。这种变化的影响几乎是积极的</p>
<p>另一方面，就我诚实的看法而言，对于 <code>for;;</code> 循环的更改的理由是不充分的。提案制定者提供的主要原因是与 <code>for-range</code> 循环保持一致性（它们都是 <code>for</code> 循环）。然而，对于认为以下类似循环中的循环变量是按迭代范围作用域的这一点来说，这并不直观</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> a, b, c := anExpression; aCondition; postStatement &#123;</span><br><span class="line">	... <span class="comment">// loop body</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在循环执行期间，<code>a、b、c := anExpression</code> 语句仅被执行一次，因此循环变量在循环执行期间只被显式实例化一次是很直观的。新的语义使得循环变量在每次迭代时都被实例化，这意味着必须有一些隐式的代码来完成这个工作。这是正确的。Go 1.22+ 规范( <a target="_blank" rel="noopener" href="https://go.dev/ref/spec#For_statements">https://go.dev/ref/spec#For_statements</a> )说：</p>
<blockquote>
<p>每次迭代都有自己单独声明的变量（或变量）。第一次迭代使用的变量由 init 语句声明。每次后续迭代使用的变量在执行 post 语句之前隐式声明，并且被初始化为该时刻上一次迭代的变量的值</p>
</blockquote>
<p>根据规范，自 Go 1.22 起，上述循环实际上等同于以下伪代码（抱歉，新的语义很难以清晰完美的方式解释。Go 的官方文档中没有一个成功达到这个目标。在这里，我已经尽力了。）:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	a_last, b_last, c_last := anExpression</span><br><span class="line">	pa_last, pb_last, pc_last = &amp;a_last, &amp;b_last, &amp;c_last</span><br><span class="line">	first := <span class="literal">true</span></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		a, b, c := *pa_last, *pb_last, *pc_last</span><br><span class="line">		<span class="keyword">if</span> first &#123;</span><br><span class="line">			first = <span class="literal">false</span></span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			postStatement</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> !(aCondition) &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		pa_last, pb_last, pc_last = &amp;a, &amp;b, &amp;c</span><br><span class="line">		... <span class="comment">// loop body</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>哇，有相当多神奇的隐式代码。对于一个倡导显式性的语言来说，这有点尴尬</p>
<p>隐式性往往会导致意想不到的惊喜，这并不奇怪。接下来将展示几个可能破坏你期望的例子</p>
<h2><span id="延迟调用捕获循环变量的行为可能会发生变化">延迟调用捕获循环变量的行为可能会发生变化</span></h2><p>一个简单的例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// demo-defer.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> counter, n := <span class="number">0</span>, <span class="number">2</span>; n &gt;= <span class="number">0</span>; n-- &#123;</span><br><span class="line">		<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">(v <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">		    fmt.Print(<span class="string">&quot;#&quot;</span>, counter, <span class="string">&quot;: &quot;</span>, v, <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">		    counter++</span><br><span class="line">		&#125;(n)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ gotv <span class="number">1.21</span>. run demo-<span class="keyword">defer</span>.<span class="keyword">go</span></span><br><span class="line">[Run]: $HOME/.cache/gotv/tag_go1<span class="number">.21</span><span class="number">.7</span>/bin/<span class="keyword">go</span> run demo-<span class="keyword">defer</span>.<span class="keyword">go</span></span><br><span class="line">#<span class="number">0</span>: <span class="number">0</span></span><br><span class="line">#<span class="number">1</span>: <span class="number">1</span></span><br><span class="line">#<span class="number">2</span>: <span class="number">2</span></span><br><span class="line">$ gotv <span class="number">1.22</span>. run demo-<span class="keyword">defer</span>.<span class="keyword">go</span></span><br><span class="line">[Run]: $HOME/.cache/gotv/tag_go1<span class="number">.22</span><span class="number">.0</span>/bin/<span class="keyword">go</span> run demo-<span class="keyword">defer</span>.<span class="keyword">go</span></span><br><span class="line">#<span class="number">0</span>: <span class="number">0</span></span><br><span class="line">#<span class="number">0</span>: <span class="number">1</span></span><br><span class="line">#<span class="number">0</span>: <span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>你会发现，自从 Go 1.22 起，<code>counter</code>的值从未得到有效增加。为什么？抱歉，如上所述，很难清晰地解释这个新语义，我不认为我有能力这样做。你可以从以下等价代码中理解这一点：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	counter_last, n_last := <span class="number">0</span>, <span class="number">2</span></span><br><span class="line">	p_counter_last, p_n_last := &amp;counter_last, &amp;n_last</span><br><span class="line">	first := <span class="literal">true</span></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		counter, n := *p_counter_last, *p_n_last</span><br><span class="line">		<span class="keyword">if</span> (first) &#123;</span><br><span class="line">			first = <span class="literal">false</span></span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			n--</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> !(n &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		p_counter_last, p_n_last = &amp;counter, &amp;n</span><br><span class="line">		<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">(v <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">			fmt.Print(<span class="string">&quot;#&quot;</span>, counter, <span class="string">&quot;: &quot;</span>, v, <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">			counter++</span><br><span class="line">		&#125;(n)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一个更实际的例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// search.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">demoFilter</span><span class="params">(n <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> n &amp; <span class="number">1</span> == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Search values and return them without perverting order.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">search</span><span class="params">(start, end <span class="type">int</span>)</span></span>(r []<span class="type">int</span>) &#123;</span><br><span class="line">	<span class="keyword">var</span> count = <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> i, index := start, <span class="number">0</span>; i &lt;= end; i++ &#123;</span><br><span class="line">		<span class="keyword">if</span> demoFilter(i) &#123;</span><br><span class="line">			count++</span><br><span class="line">			<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">(value <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">				r[index] = value</span><br><span class="line">				index++</span><br><span class="line">			&#125;(i)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	r = <span class="built_in">make</span>([]<span class="type">int</span>, count) <span class="comment">// only allocate once</span></span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(search(<span class="number">0</span>, <span class="number">9</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述程序的输出：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ gotv <span class="number">1.21</span>. run search.<span class="keyword">go</span></span><br><span class="line">[Run]: $HOME/.cache/gotv/tag_go1<span class="number">.21</span><span class="number">.7</span>/bin/<span class="keyword">go</span> run search.<span class="keyword">go</span></span><br><span class="line">[<span class="number">8</span> <span class="number">6</span> <span class="number">4</span> <span class="number">2</span> <span class="number">0</span>]</span><br><span class="line">$ gotv <span class="number">1.22</span>. run search.<span class="keyword">go</span></span><br><span class="line">[Run]: $HOME/.cache/gotv/tag_go1<span class="number">.22</span><span class="number">.0</span>/bin/<span class="keyword">go</span> run search.<span class="keyword">go</span></span><br><span class="line">[<span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>]</span><br></pre></td></tr></table></figure>
<p>因此，自从 Go 1.22 起，在使用新声明的循环变量时，在延迟函数调用中要小心</p>
<blockquote>
<p>上面的例子表明，在 <code>for;;</code> 循环中，某些新声明的循环变量预计是逐次迭代范围的，而另一些则预计是整个循环范围的。我曾建议允许重新声明语句作为 <code>for;;</code> 循环的 <code>postStatement</code>，以明确指定哪些循环变量是逐次迭代范围的( <a target="_blank" rel="noopener" href="https://github.com/golang/go/issues/60078#issuecomment-1547130632">https://github.com/golang/go/issues/60078#issuecomment-1547130632</a> )。例如，在以下循环代码中，<code>n</code> 是逐次迭代范围的，但 <code>counter</code> 是整个循环范围的</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> counter, n := <span class="number">0</span>, <span class="number">2</span>; n &gt;= <span class="number">0</span>; n := n - <span class="number">1</span> &#123; ... &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>然而，遗憾的是，这个建议被完全忽略了</p>
</blockquote>
<h2><span id="在闭包中捕获循环变量时要小心">在闭包中捕获循环变量时要小心</span></h2><p>一个例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// demo-closure-1.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> printN <span class="function"><span class="keyword">func</span><span class="params">()</span></span></span><br><span class="line">	<span class="keyword">for</span> n := <span class="number">0</span>; n &lt; <span class="number">9</span>; n++ &#123;</span><br><span class="line">		<span class="keyword">if</span> printN == <span class="literal">nil</span> &#123;</span><br><span class="line">			printN = <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">				fmt.Println(n)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	printN()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ gotv <span class="number">1.21</span>. run demo-closure<span class="number">-1.</span><span class="keyword">go</span></span><br><span class="line">[Run]: $HOME/.cache/gotv/tag_go1<span class="number">.21</span><span class="number">.7</span>/bin/<span class="keyword">go</span> run demo-closure<span class="number">-1.</span><span class="keyword">go</span></span><br><span class="line"><span class="number">9</span></span><br><span class="line">$ gotv <span class="number">1.22</span>. run demo-closure<span class="number">-1.</span><span class="keyword">go</span></span><br><span class="line">[Run]: $HOME/.cache/gotv/tag_go1<span class="number">.22</span><span class="number">.0</span>/bin/<span class="keyword">go</span> run demo-closure<span class="number">-1.</span><span class="keyword">go</span></span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>在 Go 1.22 之前，<code>printN</code> 闭包捕获的是循环变量的唯一实例，其最终值为 <code>9</code>。然而，自 Go 1.22 起，<code>printN</code> 闭包捕获的是循环变量的第一个实例，其最终值为 <code>1</code>。这就是两个 Go 版本之间行为差异的原因</p>
<p>以下是一个类似的例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// demo-closure-2.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;bytes&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> printBuf <span class="function"><span class="keyword">func</span><span class="params">()</span></span></span><br><span class="line">	<span class="keyword">for</span> buf, i := (bytes.Buffer&#123;&#125;), <span class="type">byte</span>(<span class="string">&#x27;a&#x27;</span>); i &lt;= <span class="string">&#x27;z&#x27;</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">if</span> printBuf == <span class="literal">nil</span> &#123;</span><br><span class="line">			printBuf = <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">				fmt.Printf(<span class="string">&quot;%s\n&quot;</span>, buf.Bytes())</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		buf.WriteByte(i)</span><br><span class="line">	&#125;</span><br><span class="line">	printBuf()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ gotv <span class="number">1.21</span>. run demo-closure<span class="number">-2.</span><span class="keyword">go</span></span><br><span class="line">[Run]: $HOME/.cache/gotv/tag_go1<span class="number">.21</span><span class="number">.7</span>/bin/<span class="keyword">go</span> run demo-closure<span class="number">-2.</span><span class="keyword">go</span></span><br><span class="line">abcdefghijklmnopqrstuvwxyz</span><br><span class="line">$ gotv <span class="number">1.22</span>. run demo-closure<span class="number">-2.</span><span class="keyword">go</span></span><br><span class="line">[Run]: $HOME/.cache/gotv/tag_go1<span class="number">.22</span><span class="number">.0</span>/bin/<span class="keyword">go</span> run demo-closure<span class="number">-2.</span><span class="keyword">go</span></span><br><span class="line">a</span><br></pre></td></tr></table></figure>

<p>第三个例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> next <span class="function"><span class="keyword">func</span><span class="params">()</span></span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; next() &#123;</span><br><span class="line">        <span class="built_in">print</span>(i)</span><br><span class="line">        next = <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            i++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>自从 Go 1.22 起，它永远不会退出（在 Go 1.22 之前，它打印 <code>012</code> 然后立即退出）</p>
<blockquote>
<p>因此，不论您认为这是否直观，请记住，自从 Go 1.22 起，一个新声明的循环变量在运行时可能有多个实例，无论在 <code>postStatement</code> 中是否被修改。每个实例都在一个迭代中实例化</p>
</blockquote>
<h2><span id="在获取循环变量的地址时要小心">在获取循环变量的地址时要小心</span></h2><p>同样地，自从 Go 1.22 起，在循环迭代中使用新声明的循环变量的地址可能是危险的</p>
<p>例如，下面的 Go 程序会打印什么？（有些人说这个例子太奇怪了，不应为这种情况保留向后兼容性。这是多么荒谬的观点。实际上的代码可能比这更奇怪！）</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// demo-pointer1.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i, p := <span class="number">0</span>, (*<span class="type">int</span>)(<span class="literal">nil</span>); p == <span class="literal">nil</span>; fmt.Println(p == &amp;i) &#123;</span><br><span class="line">		p = &amp;i</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ gotv <span class="number">1.21</span>. run demo-pointer1.<span class="keyword">go</span></span><br><span class="line">[Run]: $HOME/.cache/gotv/tag_go1<span class="number">.21</span><span class="number">.7</span>/bin/<span class="keyword">go</span> run demo-pointer1.<span class="keyword">go</span></span><br><span class="line"><span class="literal">true</span></span><br><span class="line">$ gotv <span class="number">1.22</span>. run demo-pointer1.<span class="keyword">go</span></span><br><span class="line">[Run]: $HOME/.cache/gotv/tag_go1<span class="number">.22</span><span class="number">.0</span>/bin/<span class="keyword">go</span> run demo-pointer1.<span class="keyword">go</span></span><br><span class="line"><span class="literal">false</span></span><br></pre></td></tr></table></figure>

<p>Go 1.21 和 1.22 给出了不同的答案。为什么？从下面显示的等效代码中，我们可以得知，在比较 <code>p == &amp;i</code> 时，<code>p</code> 指向 <code>i</code> 的第一个实例，而 <code>&amp;i</code> 取得 <code>i</code> 的第二个实例的地址。因此，比较的评估结果是 <code>false</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	i_last, p_last := <span class="number">0</span>, (*<span class="type">int</span>)(<span class="literal">nil</span>)</span><br><span class="line">	p_i_last, p_p_last := &amp;i_last, &amp;p_last</span><br><span class="line">	first := <span class="literal">true</span></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		i, p := *p_i_last, *p_p_last</span><br><span class="line">		<span class="keyword">if</span> first &#123;</span><br><span class="line">			first = <span class="literal">false</span></span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			fmt.Println(p == &amp;i)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> !(p == <span class="literal">nil</span>) &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		p_i_last, p_p_last = &amp;i, &amp;p</span><br><span class="line">		p = &amp;i</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另一个例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// demo-pointer2.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> p *<span class="type">int</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; *p++ &#123;</span><br><span class="line">	    p = &amp;i</span><br><span class="line">	    fmt.Println(i)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>自从 Go 1.22 起，上面的程序将永远不会退出（在 Go 1.22 之前，它会退出）：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ gotv <span class="number">1.21</span>. run demo-pointer2.<span class="keyword">go</span></span><br><span class="line">[Run]: $HOME/.cache/gotv/tag_go1<span class="number">.21</span><span class="number">.7</span>/bin/<span class="keyword">go</span> run demo-pointer2.<span class="keyword">go</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line">$ gotv <span class="number">1.22</span>. run demo-pointer2.<span class="keyword">go</span></span><br><span class="line">[Run]: $HOME/.cache/gotv/tag_go1<span class="number">.22</span><span class="number">.0</span>/bin/<span class="keyword">go</span> run demo-pointer2.<span class="keyword">go</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h2><span id="将第三个子句语句移到循环体内时要小心">将第三个子句语句移到循环体内时要小心</span></h2><p>自从 Go 1.22 起，以下两个循环可能不再等价（在 Go 1.22 之前它们是等价的）</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> ...; ...; postStatement &#123;</span><br><span class="line">	... <span class="comment">// no continue statements here</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> ...; ...; &#123;</span><br><span class="line">	... <span class="comment">// no continue statements here</span></span><br><span class="line">	postStatement</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例如，如果我们将最后一节中的循环的第三个子句语句移到循环体内，那么它们的行为就会发生变化（自从 Go 1.22 起）</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// demo-pointer3.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">pointerDemo1</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i, p := <span class="number">0</span>, (*<span class="type">int</span>)(<span class="literal">nil</span>); p == <span class="literal">nil</span>; &#123;</span><br><span class="line">		p = &amp;i</span><br><span class="line">		fmt.Println(p == &amp;i) <span class="comment">// the old 3rd clause</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">pointerDemo2</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> p *<span class="type">int</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; &#123;</span><br><span class="line">	    p = &amp;i</span><br><span class="line">	    fmt.Println(i)</span><br><span class="line">	    *p++ <span class="comment">// the old 3rd clause</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	pointerDemo1();</span><br><span class="line">	pointerDemo2();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>新输出：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ gotv <span class="number">1.22</span>. run demo-pointer3.<span class="keyword">go</span></span><br><span class="line">[Run]: $HOME/.cache/gotv/tag_go1<span class="number">.22</span><span class="number">.0</span>/bin/<span class="keyword">go</span> run demo-pointer3.<span class="keyword">go</span></span><br><span class="line"><span class="literal">true</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure>

<h2><span id="在声明不可复制的值作为循环变量时要小心">在声明不可复制的值作为循环变量时要小心</span></h2><p>如上所述，自从 Go 1.22 起，每次循环迭代开始时，每个新声明的循环变量将隐式地被复制一次。这意味着，自从 Go 1.22 起，不建议将不可复制的值声明为循环变量，例如 <code>sync.Mutex</code>、<code>sync/atomic.Int64</code>、<code>bytes.Buffer</code> 和 <code>strings.Builder</code> 等值</p>
<p>例如，在 Go 1.22 之前的版本中，以下代码被认为在并发上是正确的。然而，从 Go 1.22 开始，这段代码被认为存在并发问题，因为循环变量 <code>wg</code> 将在每次循环迭代开始时（隐式）被复制</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// demo-nocopy1.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">process</span><span class="params">()</span></span> (wait <span class="function"><span class="keyword">func</span><span class="params">()</span></span>) &#123;</span><br><span class="line">	<span class="keyword">for</span> wg, i := (sync.WaitGroup&#123;&#125;), <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">if</span> (wait == <span class="literal">nil</span>) &#123;</span><br><span class="line">			wait = wg.Wait</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		wg.Add(<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(v <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">			<span class="keyword">defer</span> wg.Done()</span><br><span class="line">			<span class="keyword">if</span> (v &gt; <span class="number">0</span>) &#123;</span><br><span class="line">				time.Sleep(time.Second/<span class="number">8</span>)</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">println</span>(v)</span><br><span class="line">		&#125;(i)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	process()()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ gotv <span class="number">1.21</span>. run demo-nocopy1.<span class="keyword">go</span></span><br><span class="line">[Run]: $HOME/.cache/gotv/tag_go1<span class="number">.21</span><span class="number">.8</span>/bin/<span class="keyword">go</span> run demo-nocopy1.<span class="keyword">go</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line">$ gotv <span class="number">1.22</span>. run demo-nocopy1.<span class="keyword">go</span></span><br><span class="line">[Run]: $HOME/.cache/gotv/tag_go1<span class="number">.22</span><span class="number">.1</span>/bin/<span class="keyword">go</span> run demo-nocopy1.<span class="keyword">go</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line">$ gotv <span class="number">1.22</span>. vet demo-nocopy1.<span class="keyword">go</span></span><br><span class="line">[Run]: $HOME/.cache/gotv/tag_go1<span class="number">.22</span><span class="number">.1</span>/bin/<span class="keyword">go</span> vet demo-nocopy1.<span class="keyword">go</span></span><br></pre></td></tr></table></figure>

<p>请注意，Go 1.22 工具链中的 <code>go vet</code> 命令无法捕捉到这种不可复制值的隐式复制，无论循环变量 <code>wg</code> 是否在循环体内被捕获</p>
<p>某些不可复制值的检查发生在运行时。让我们看一个使用 <code>strings.Builder</code> 的例子（每个 <code>strings.Builder</code> 值都包含应该指向自身的指针字段）：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// demo-nocopy2.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;strings&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Debug = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">a2z</span><span class="params">(callback <span class="keyword">func</span>(*strings.Builder)</span></span>) <span class="type">string</span> &#123;</span><br><span class="line">	<span class="keyword">for</span> b, i := (strings.Builder&#123;&#125;), <span class="type">byte</span>(<span class="string">&#x27;a&#x27;</span>); ; i++ &#123;</span><br><span class="line">		b.WriteByte(i)</span><br><span class="line">		<span class="keyword">if</span> (Debug) &#123; callback(&amp;b) &#125;</span><br><span class="line">		<span class="keyword">if</span> i == <span class="string">&#x27;z&#x27;</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> b.String()</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	debugProcess := <span class="function"><span class="keyword">func</span><span class="params">(pb *strings.Builder)</span></span> &#123;</span><br><span class="line">		<span class="comment">//fmt.Println(pb.String()) // do nothing</span></span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(a2z(debugProcess))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用不同的 Go 工具链运行它，我们得到：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ gotv <span class="number">1.21</span>. run demo-nocopy2.<span class="keyword">go</span></span><br><span class="line">[Run]: $HOME/.cache/gotv/tag_go1<span class="number">.21</span><span class="number">.7</span>/bin/<span class="keyword">go</span> run demo-nocopy2.<span class="keyword">go</span></span><br><span class="line">abcdefghijklmnopqrstuvwxyz</span><br><span class="line">$ gotv <span class="number">1.22</span>. run demo-nocopy2.<span class="keyword">go</span></span><br><span class="line">[Run]: $HOME/.cache/gotv/tag_go1<span class="number">.22</span><span class="number">.0</span>/bin/<span class="keyword">go</span> run demo-nocopy2.<span class="keyword">go</span></span><br><span class="line"><span class="built_in">panic</span>: strings: illegal use of non-zero Builder copied by value</span><br><span class="line"></span><br><span class="line">goroutine <span class="number">1</span> [running]:</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>是的，运行时的不可复制检查是有效的。自从 Go 1.22 开始，当类型为 <code>strings.Builder</code> 的循环变量被复制时，将创建一个 panic。在 Go 1.22 之前，这种复制是不会发生的，因此不会有 panic</p>
<p>请注意，从 Go 1.22 开始，Go 编译器可能会将新声明的循环变量优化为仅在整个循环中实例化一次，即使它们的语义表明需要每次迭代实例化。当编译器确定每个循环变量实例仅在相应迭代的生命周期内使用时，这种优化就会发生</p>
<p>让我们将上面示例中的 <code>Debug</code> 常量更改为 <code>false</code>，然后再使用 1.22 工具链运行该示例</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ gotv <span class="number">1.22</span>. run demo-nocopy.<span class="keyword">go</span></span><br><span class="line">[Run]: $HOME/.cache/gotv/tag_go1<span class="number">.22</span><span class="number">.0</span>/bin/<span class="keyword">go</span> run demo-nocopy.<span class="keyword">go</span></span><br><span class="line">abcdefghijklmnopqrstuvwxyz</span><br></pre></td></tr></table></figure>

<p>现在我们可以发现没有发生 panic。为什么呢？因为现在 <code>if (Debug) &#123; callback(&amp;b) &#125;</code> 这行代码变成了死代码，这使得编译器认为循环变量 <code>b</code> 的每个实例仅在相应迭代的生命周期内被使用。因此，循环变量 <code>b</code> 只在整个循环中实例化一次，并且不会出现多次复制的情况</p>
<p>然而，编译器在这里做出了错误的决定( <a target="_blank" rel="noopener" href="https://github.com/golang/go/issues/66070">https://github.com/golang/go/issues/66070</a> )。编译器错误地实现了语义。示例程序应该无论 <code>Debug</code> 常量的值如何都会发生 panic。尽管这种特定情况可能被认为是可以接受的，因为缺乏有害后果，但这引发了对其他情况下可能出现意外行为的担忧</p>
<p>安全建议是尽量不将不可复制的值声明为循环变量。这只是一个建议，而不是强制规则，因为复制不可复制的值并不总是会造成损害（但在稍后以某种方式重构代码时可能会暴露损害）</p>
<h2><span id="警告你的-go-程序的性能可能会默默地降低">警告：你的 Go 程序的性能可能会默默地降低</span></h2><p>有时候，编译器可能会过于聪明；有时候，它又不够聪明。例如，有时候在 Go 工具链 1.22 中提供的官方标准编译器无法确定新声明的循环变量的每个实例是否仅在相应迭代的生命周期内被使用，因此循环变量将在每次迭代中被实例化，而其每个实例都将被分配到堆上而不是栈上。更糟糕的是，如果循环变量的大小很大，那么将产生很高的复制成本。当出现这些情况时，程序的性能将会下降</p>
<p>让我们看一个例子，在这个例子中，在 <code>bar</code> 函数中使用了一个大小很大的循环变量</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// demo-largesize.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Large [<span class="number">1</span>&lt;&lt;<span class="number">10</span>]<span class="type">byte</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">(constFunc <span class="keyword">func</span>(*Large, <span class="type">int</span>)</span></span>) &#123;</span><br><span class="line">	a := Large&#123;&#125;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(a); i++ &#123;</span><br><span class="line">		constFunc(&amp;a, i)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">bar</span><span class="params">(constFunc <span class="keyword">func</span>(*Large, <span class="type">int</span>)</span></span>) &#123;</span><br><span class="line">	<span class="keyword">for</span> a, i := (Large&#123;&#125;), <span class="number">0</span>; i &lt; <span class="built_in">len</span>(a); i++ &#123;</span><br><span class="line">		constFunc(&amp;a, i)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	readonly := <span class="function"><span class="keyword">func</span><span class="params">(x *Large, k <span class="type">int</span>)</span></span> &#123;&#125;</span><br><span class="line">	bench := <span class="function"><span class="keyword">func</span><span class="params">(f <span class="keyword">func</span>(<span class="keyword">func</span>(*Large, <span class="type">int</span>)</span></span>)) time.Duration &#123;</span><br><span class="line">		start := time.Now()</span><br><span class="line">		f(readonly)</span><br><span class="line">		<span class="keyword">return</span> time.Since(start)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(<span class="string">&quot;foo time:&quot;</span>, bench(foo))</span><br><span class="line">	fmt.Println(<span class="string">&quot;bar time:&quot;</span>, bench(bar))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ gotv <span class="number">1.21</span>. run aaa.<span class="keyword">go</span></span><br><span class="line">[Run]: $HOME/.cache/gotv/tag_go1<span class="number">.21</span><span class="number">.7</span>/bin/<span class="keyword">go</span> run aaa.<span class="keyword">go</span></span><br><span class="line">foo time: <span class="number">3.573</span>µs</span><br><span class="line">bar time: <span class="number">3.267</span>µs</span><br><span class="line">$ gotv <span class="number">1.22</span>. run aaa.<span class="keyword">go</span></span><br><span class="line">[Run]: $HOME/.cache/gotv/tag_go1<span class="number">.22</span><span class="number">.0</span>/bin/<span class="keyword">go</span> run aaa.<span class="keyword">go</span></span><br><span class="line">foo time: <span class="number">3.819</span>µs</span><br><span class="line">bar time: <span class="number">552.246</span>µs</span><br></pre></td></tr></table></figure>

<p>基准测试结果显示，在 Go 1.21 和 1.22 之间的 <code>bar</code> 函数中存在显著的性能回退。为什么呢？因为在官方标准的 Go 编译器 1.22 中，<code>bar</code> 函数中的循环变量 a 在每次迭代中都会被复制。而在以前的版本中，这种复制总是不必要的</p>
<p>性能下降问题并不影响代码逻辑的正确性，因此可能不会及时被发现</p>
<p>避免这种性能下降问题的建议：</p>
<ol>
<li>尽量不要将大型值声明为循环变量，即使语法允许。</li>
<li>在某些情况下，考虑将循环变量声明在循环之外，以优化性能。如果你可以保证这些变量不需要在每次迭代中被实例化，这将是有益的</li>
</ol>
<h2><span id="警告当循环变量被并发使用时情况可能会变得比以前更加微妙">警告：当循环变量被并发使用时，情况可能会变得比以前更加微妙</span></h2><p>首先，让我们看一个简单的程序：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// demo-concurency1.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line">		wg.Add(<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			<span class="keyword">defer</span> wg.Done()</span><br><span class="line">			fmt.Println(i)</span><br><span class="line">		&#125;()</span><br><span class="line">	&#125;</span><br><span class="line">	wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的程序旨在打印每次迭代中循环变量 <code>i</code> 的值。在 Go 1.22 之前，该程序存在明显的数据竞争条件，因为在整个循环过程中，循环变量 <code>i</code> 只被实例化一次。所有新创建的 goroutine 都将读取单个实例，但主 goroutine 将修改它。以下输出证明了这一事实：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ CGO_ENABLED=<span class="number">1</span> gotv <span class="number">1.21</span>. run -race demo-concurency1.<span class="keyword">go</span></span><br><span class="line">[Run]: $HOME/.cache/gotv/tag_go1<span class="number">.21</span><span class="number">.7</span>/bin/<span class="keyword">go</span> run -race demo-concurency1.<span class="keyword">go</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line">==================</span><br><span class="line">WARNING: DATA RACE</span><br><span class="line">...</span><br><span class="line">==================</span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure>

<p>在 Go 1.22 之前，修复方法很简单，只需要在循环体的开头添加一行 <code>i := i</code>。Go 1.22 通过改变 <code>for;;</code> 循环的语义来修复了指定的数据竞争问题，而不需要修改旧的有问题的代码。这可以通过以下输出进行验证：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ CGO_ENABLED=<span class="number">1</span> gotv <span class="number">1.22</span>. run -race demo-concurency1.<span class="keyword">go</span></span><br><span class="line">[Run]: $HOME/.cache/gotv/tag_go1<span class="number">.22</span><span class="number">.0</span>/bin/<span class="keyword">go</span> run -race demo-concurency1.<span class="keyword">go</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>事实上，这正是 Go 1.22 对 <code>for;;</code> 循环进行语义更改的原因。但是否值得通过引入神奇的隐式代码来修复这样一个小问题呢？</p>
<p>通过改变语义来尝试修复问题的效果实际上是有限的。让我们稍微修改上面的程序：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// demo-concurency2.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line">		wg.Add(<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			<span class="keyword">defer</span> wg.Done()</span><br><span class="line">			i++ <span class="comment">// &lt;-- add this line</span></span><br><span class="line">			fmt.Println(i)</span><br><span class="line">		&#125;()</span><br><span class="line">	&#125;</span><br><span class="line">	wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>新代码是否仍然是无数据竞争的（采用 Go 1.22 的语义）？看起来不错。每个新创建的 goroutine 只是使用循环变量 <code>i</code> 的一个独立副本。但答案是否定的，因为在每次迭代开始时有一个隐式赋值，而这个隐式赋值使用循环变量的一个实例作为源值（即主 goroutine 读取它），然而该实例会在一个新创建的 goroutine 中被修改</p>
<p>以下输出验证了新代码中存在数据竞争条件：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ CGO_ENABLED=<span class="number">1</span> gotv <span class="number">1.22</span>. run -race demo-concurency2.<span class="keyword">go</span></span><br><span class="line">[Run]: $HOME/.cache/gotv/tag_go1<span class="number">.22</span><span class="number">.0</span>/bin/<span class="keyword">go</span> run -race demo-concurency2.<span class="keyword">go</span></span><br><span class="line">==================</span><br><span class="line">WARNING: DATA RACE</span><br><span class="line">...</span><br><span class="line">==================</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line">Found <span class="number">1</span> data race(s)</span><br></pre></td></tr></table></figure>

<p>在 Go 1.22 之前，数据竞争是明显且容易检测到的。但自从 Go 1.22 以后，事情变得更加微妙，数据竞争并不是很明显（因为有隐式代码的存在）</p>
<p>你可能已经发现，存在数据竞争的程序似乎产生了预期的输出。是的，这是语义变更的另一个问题。虽然存在数据竞争的程序的输出大部分时间看起来是正确的，但这掩盖了一个更深层次的问题：数据竞争可能在较长时间内未被发现。这会显著延迟问题的识别和解决！</p>
<p>更严重的是，一些原本正常的并发代码会变得有问题。以下是一个示例：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// demo-concurency3.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> NumWorkers = <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isGold</span><span class="params">(num <span class="type">uint64</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> num &amp; <span class="number">0xFFFFF</span> == <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> c = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">uint64</span>)</span><br><span class="line">	<span class="keyword">var</span> m sync.Mutex</span><br><span class="line">	<span class="keyword">for</span> n, i := <span class="number">0</span>, <span class="type">uint64</span>(<span class="number">0</span>); n &lt; NumWorkers; n++ &#123;</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			<span class="keyword">for</span> &#123;</span><br><span class="line">				m.Lock()</span><br><span class="line">				i++</span><br><span class="line">				v := i</span><br><span class="line">				m.Unlock()</span><br><span class="line"></span><br><span class="line">				<span class="keyword">if</span> isGold(v) &#123;</span><br><span class="line">					c &lt;- v</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> n := <span class="keyword">range</span> c &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;Found gold&quot;</span>, n)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用不同的工具链版本运行它，得到以下输出：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">$ CGO_ENABLED=<span class="number">1</span> gotv <span class="number">1.21</span>. run -race demo-concurency3.<span class="keyword">go</span></span><br><span class="line">[Run]: $HOME/.cache/gotv/tag_go1<span class="number">.21</span><span class="number">.7</span>/bin/<span class="keyword">go</span> run -race demo-concurency3.<span class="keyword">go</span></span><br><span class="line">Found gold <span class="number">1048576</span></span><br><span class="line">Found gold <span class="number">2097152</span></span><br><span class="line">Found gold <span class="number">3145728</span></span><br><span class="line">...</span><br><span class="line">^C</span><br><span class="line">$ CGO_ENABLED=<span class="number">1</span> gotv <span class="number">1.22</span>. run -race demo-concurency3.<span class="keyword">go</span></span><br><span class="line">[Run]: $HOME/.cache/gotv/tag_go1<span class="number">.22</span><span class="number">.0</span>/bin/<span class="keyword">go</span> run -race demo-concurency3.<span class="keyword">go</span></span><br><span class="line">==================</span><br><span class="line">WARNING: DATA RACE</span><br><span class="line">...</span><br><span class="line">==================</span><br><span class="line">Found gold <span class="number">1048576</span></span><br><span class="line">Found gold <span class="number">1048576</span></span><br><span class="line">Found gold <span class="number">1048576</span></span><br><span class="line">Found gold <span class="number">2097152</span></span><br><span class="line">Found gold <span class="number">2097152</span></span><br><span class="line">Found gold <span class="number">2097152</span></span><br><span class="line">Found gold <span class="number">3145728</span></span><br><span class="line">Found gold <span class="number">3145728</span></span><br><span class="line">Found gold <span class="number">3145728</span></span><br><span class="line">...</span><br><span class="line">^C</span><br></pre></td></tr></table></figure>

<p>😳😳😳…（考虑到提出进行语义更改的标题是“提案：更少出错的循环变量作用域”。）</p>
<p>在本节提到的如何修复新的存在数据竞争的代码？我们仍然可以使用旧的技巧：只需在循环体的开头添加一行 <code>i := i</code>。是的，在 Go 1.22+ 时代，这仍然是避免数据竞争的最佳建议。这是否是对新的语义（<code>for;;</code> 循环）的嘲讽？</p>
<h2><span id="一些建议">一些建议</span></h2><p>好的，以上是我目前在 Go 1.22 中引入的新 for;; 语义中已经识别出的潜在问题。可能还有更多，我不太确定</p>
<p>以下是您可以在 Go 1.22+ 时代遵循的一些建议：</p>
<h3><span id="为-go-源文件指定-go-语言版本">为 Go 源文件指定 Go 语言版本</span></h3><p>正如上面的示例所演示的那样，Go 1.22 中进行的语义更改破坏了向后兼容性。为了尽可能地减小损害，Go 核心团队决定将 Go 语言版本与每个 Go 源文件关联起来。换句话说，自 Go 1.22 起，一个 Go 源文件 &#x3D; 代码 + Go 语言版本</p>
<p>有几种方式（按优先顺序）可以为 Go 源文件指定 Go 语言版本：</p>
<ol>
<li>在源文件开头添加 <code>//go:build go1.xy</code> 注释指令，以指定源文件的语言版本</li>
<li>在构建 Go 二进制文件时使用 <code>-gcflags=-lang=go1.xy</code> 编译器选项，以指定传递给编译器的种子文件的 Go 语言版本</li>
<li>在 Go 模块的 <code>go.mod</code> 文件中放置一条 <code>go 1.xy</code> 指令行，以指定 Go 模块中所有源文件的默认 Go 语言版本。缺少 go 指令行被视为 <code>go 1.16</code>。指令行的影响: <a target="_blank" rel="noopener" href="https://go.dev/ref/mod#go-mod-file-go">https://go.dev/ref/mod#go-mod-file-go</a></li>
</ol>
<p>如果以上所有方式都没有为 Go 源文件指定 Go 语言版本，则使用所用 Go 编译器的版本。换句话说，源文件中代码的行为取决于编译器</p>
<p>这种设计引起了两个问题：</p>
<ol>
<li>有些人喜欢使用 <code>go run</code> 命令作为脚本运行 Go 代码（一组没有 <code>go.mod</code> 文件的 Go 源文件）。如果 Go 脚本源文件不包含 <code>//go:build go1.xy</code> 注释指令，并且未指定 <code>-gcflags=-lang=go1.xy</code> 编译器选项，则脚本文件中代码的行为取决于编译器，就像上面的示例所展示的那样</li>
<li>如果由于某种原因（例如使用新版本 Go 提供的功能），您将自己维护的 Go 模块的语言版本升级到 1.22 或更高版本，则 Go 模块的行为可能会发生变化。如果行为变化没有及时检测到（由于测试不足等原因），则可能会出现问题</li>
</ol>
<p>无论如何，自 Go 1.22 起，您都应尝试以任何以上介绍的方式为每个 Go 源文件指定 Go 语言版本，以避免编译器版本相关的行为。这是在 Go 1.22+ 时代成为专业 Go 程序员的最低标准</p>
<h3><span id="升级模块版本">升级模块版本</span></h3><p>如果你正在维护一个公共的 Go 模块，这个模块被其他 Go 项目所依赖，请在将语言版本升级到 Go 1.22+ 后，在 go.mod 文件中仔细检查模块代码中所有 <code>for;;</code> 循环的使用。特别要注意那些新声明的循环变量，在 <code>postStatement</code> 中没有被修改的情况</p>
<p>如果你升级了你的 Go 项目的依赖模块，请特别注意那些语言版本从旧的 Go 1.22 之前的版本升级到 Go 1.22 或更高版本的依赖模块</p>
<h3><span id="如果你担心会受到新语义的影响建议避免在-for-循环中使用新声明的循环变量">如果你担心会受到新语义的影响，建议避免在 <code>for;;</code> 循环中使用新声明的循环变量</span></h3><p>不要太紧张。 :D 实际上，大多数 <code>for;;</code> 循环在使用旧语义或新语义时都会表现相同。但是如果你对新语义感到不确定，你可以通过使用旧语义重写以下类似的循环来解决：</p>
<p>将</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> a, b, c := anExpression; aCondition; postStatement &#123;</span><br><span class="line">	... <span class="comment">// loop body</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>作为</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	a, b, c := anExpression</span><br><span class="line">	<span class="keyword">for</span> ; aCondition; postStatement &#123;</span><br><span class="line">		... <span class="comment">// loop body</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以避免触发新语义。你甚至可以指定哪些循环变量会在每次循环迭代中被实例化，哪些不会被实例化。例如，在下面的代码中，<code>a</code> 和 <code>c</code> 在每次循环迭代中都会被实例化，但是 <code>b</code> 只会在整个循环期间被实例化一次</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	a, b, c := anExpression</span><br><span class="line">	<span class="keyword">for</span> ; aCondition; postStatement &#123;</span><br><span class="line">		a, c := a, c</span><br><span class="line">		... <span class="comment">// loop body</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这有点尴尬，但更安全</p>
<h2><span id="结语">结语</span></h2><p>总的来说，我认为 <code>for-range</code> 循环的新语义对代码影响是正面的，而 <code>for;;</code> 循环的新语义则是负面的。这只是我的个人观点</p>
<p>因为引入了神奇的隐式性，<code>for;;</code> 循环的新语义在某些情况下可能需要额外的代码编写调试时间和代码审查和理解的额外认知努力</p>
<p><code>for;;</code> 循环的新语义可能会在现有代码中引入潜在的性能下降和数据竞争问题，需要仔细审核和潜在调整。根据具体情况，这样的问题可以及时发现或者不发现</p>
<p>我诚实地认为，<code>for;;</code> 循环的新语义的好处很少且微小，而缺点更为突出和严重</p>
<p>Go 1.22 中引入的语义变化显著降低了维护向后兼容性的门槛。这是一个不好的开始</p>
<p>我在以下评论中表达了我的观点：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/golang/go/issues/60078#issuecomment-1541407014">https://github.com/golang/go/issues/60078#issuecomment-1541407014</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/golang/go/issues/60078#issuecomment-1544324607">https://github.com/golang/go/issues/60078#issuecomment-1544324607</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/golang/go/issues/60078#issuecomment-1547130632">https://github.com/golang/go/issues/60078#issuecomment-1547130632</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/golang/go/issues/60078#issuecomment-1558730767">https://github.com/golang/go/issues/60078#issuecomment-1558730767</a></li>
</ul>
<p>但是，提议者（一些 Go 核心团队成员）完全忽略了它们，并决定无论如何继续进行 <code>for;;</code> 循环的语义更改</p>
<p>已经发生的事情无法改变。最后，我希望本文可以帮助你在 Go 1.22+ 时代编写专业的 Go 代码</p>

        
      </div>

         
    </div>
    
     
  </div>
  
    
<nav id="article-nav">
  <a class="article-nav-btn left  disabled "
     >
    <i class="fa-solid fa-angle-left"></i>
    <p class="title-text">
        
    </p>
  </a>
  <a class="article-nav-btn right "
    
      href="/2024/02/15/Rust%E5%BC%95%E7%94%A8%E5%AE%89%E5%85%A8/"
      title="Rust引用安全"
     >

    <p class="title-text">
      
        Rust引用安全
        
    </p>
    <i class="fa-solid fa-angle-right"></i>
  </a>
</nav>


  
</article>




    </div>
    <div id="footer-wrapper">
      <footer id="footer">
  
  <div id="footer-info" class="inner">
    
    &copy; 2024 threeWater<br>
    Powered by <a href="https://hexo.io/" target="_blank">Hexo</a> & Theme <a target="_blank" rel="noopener" href="https://github.com/saicaca/hexo-theme-vivia">Vivia</a>
  </div>
</footer>

    </div>
    <div class="back-to-top-wrapper">
    <button id="back-to-top-btn" class="back-to-top-btn hide" onclick="topFunction()">
        <i class="fa-solid fa-angle-up"></i>
    </button>
</div>

<script>
    function topFunction() {
        window.scroll({ top: 0, behavior: 'smooth' });
    }
    let btn = document.getElementById('back-to-top-btn');
    function scrollFunction() {
        if (document.body.scrollTop > 600 || document.documentElement.scrollTop > 600) {
            btn.classList.remove('hide')
        } else {
            btn.classList.add('hide')
        }
    }
    window.onscroll = function() {
        scrollFunction();
    }
</script>

  </div>
  <script src="/js/light-dark-switch.js"></script>
</body>
</html>
